
if (!exists("called_from_main", inherits = FALSE)) {
  stop("This script must be sourced from a main script.")
}

#' Source a script while retaining its path
#'
#' This function sources an R script in a local environment, keeping the script's directory
#' available and exporting all functions to the parent environment.
#'
#' @param path Character. Path to the R script to source.
#' @return Invisibly returns the local environment containing sourced objects.
#' @examples
#' \dontrun{
#' source_with_script_path("scripts/load_or_install_package.r")
#' }
source_with_script_path <- function(path) {
	path <- normalizePath(path)

    parent_env <- parent.frame()
    local_env <- new.env(parent = parent_env)

	local_env$script_path <- dirname(path)

	local_env$called_from_main <- TRUE

	sys.source(path, envir = local_env)

	for (name in ls(local_env)) {
		obj <- local_env[[name]]
		if (is.function(obj)) {
			assign(name, obj, envir = parent_env)
		}
	}

	invisible(local_env)
}


source_with_script_path(file.path(script_path, "generate_individual.r"))
source_with_script_path(file.path(script_path, "growthCurve.r"))
source_with_script_path(file.path(script_path, "max_voracity_functions.r"))


#' Generate and Simulate an Individual with Specific Parameters
#'
#' This function generates an individual with traits derived from the species data and 
#' specified parameter adjustments, and then simulates its life history using both limited 
#' and unlimited voracity functions.
#'
#' @param data_species list. A list containing species-specific data, including traits, 
#'   growth parameters, reproduction parameters, and environmental information.
#' @param timeAddedToMeetLastRepro numeric. Additional time to adjust the last reproduction 
#'   event timing.
#' @param N numeric. Scaling parameter for individual generation (e.g., population size or 
#'   individual index).
#' @param corrLk numeric. Correlation parameter between length and growth rate \(k\).
#' @param corrLdevT numeric. Correlation parameter between length and development time.
#' @param corrkdevT numeric. Correlation parameter between growth rate \(k\) and development time.
#' @param simulationType character. Type of simulation (e.g., "Dinosaurs", "Arthropods", "Aquatic").
#' @param temperature numeric or character. Temperature for simulation, or "useTempFromLab" 
#'   to use the laboratory-measured temperature from `data_species`.
#' @param propMov numeric. Proportion of time the individual spends moving, used in metabolic rate calculations.
#' @param multiplierForFieldMetabolicRate numeric. Multiplier to adjust metabolic rate for field conditions.
#' @param timeStep numeric. Time step of the simulation.
#' @param includeMetabolicRate logical. Whether to include metabolic rate in growth and voracity calculations.
#' @param profitability numeric. Profitability parameter used in energy gain calculations.
#' @param silent logical. If TRUE, suppresses verbose messages during individual generation.
#' @param todayEncountersWithPredators numeric. Number of predator encounters today.
#' @param maxEncountersPerDayInPop numeric. Maximum number of predator encounters per day in the population.
#'
#' @return list. A list containing:
#'   \itemize{
#'     \item simulations: A list of two data frames (time series) generated by `simulateIndividual`:
#'       \describe{
#'         \item{Limited}{Simulation using `calculatePreFinalVoracityLimited` function.}
#'         \item{Unlimited}{Simulation using `calculatePreFinalVoracityUnlimited` function.}
#'       }
#'     \item individual: The generated individual with traits and parameters used in the simulation.
#'   }
#'
#' @details
#' The function first generates an individual using `generateIndividual()` based on the species 
#' data and parameter correlations. If `temperature` is set to `"useTempFromLab"`, it uses the 
#' laboratory-measured temperature stored in `data_species$tempFromLab`. The individual is then 
#' simulated over its life history twice: once with a limited pre-final voracity function and 
#' once with an unlimited function, producing two separate simulation outputs. The function 
#' sets a fixed seed (`123`) to ensure reproducibility of individual generation.
#'
#' @examples
#' \dontrun{
#' result <- tryParams(
#'   data_species = mySpeciesData,
#'   timeAddedToMeetLastRepro = 0,
#'   N = 1,
#'   corrLk = 0.2,
#'   corrLdevT = 0.1,
#'   corrkdevT = 0.3,
#'   simulationType = "Dinosaurs",
#'   temperature = "useTempFromLab",
#'   propMov = 0.5,
#'   multiplierForFieldMetabolicRate = 1.2,
#'   timeStep = 1,
#'   includeMetabolicRate = TRUE,
#'   profitability = 1.0,
#'   silent = TRUE,
#'   todayEncountersWithPredators = 2,
#'   maxEncountersPerDayInPop = 10
#' )
#' names(result$simulations)
#' }
#'
#' @export
tryParams<-function(data_species, timeAddedToMeetLastRepro, N, corrLk, corrLdevT, corrkdevT, simulationType, temperature, propMov, multiplierForFieldMetabolicRate, timeStep, includeMetabolicRate, profitability, silent, todayEncountersWithPredators, maxEncountersPerDayInPop)
{
	#' Decompose Organism Mass Into Functional Components
	#'
	#' This function splits an organism’s total dry mass into two biologically
	#' meaningful components: the energy tank (reserve mass) and the body size
	#' (structural mass). The decomposition follows an allometric scaling rule
	#' where the energy tank grows with dry mass raised to a specified exponent.
	#'
	#' @param dryMass numeric. Total dry mass of the organism.
	#' @param energyTankTraitValue numeric. Trait scaling factor determining the
	#'        proportion of mass allocated to the energy tank.
	#' @param betaScaleTank numeric. Allometric exponent controlling how the
	#'        energy tank scales with total dry mass.
	#'
	#' @return A list with two numeric elements:
	#' \describe{
	#'   \item{energyTank}{Mass allocated to the energy tank (reserve).}
	#'   \item{bodySize}{Structural body mass (dryMass minus energyTank).}
	#' }
	#'
	#' @details
	#' The energy tank is computed as:
	#' \deqn{energyTank = energyTankTraitValue \times dryMass^{betaScaleTank}}
	#'
	#' The remaining mass is considered structural body mass.
	#'
	#' This decomposition is commonly used in dynamic energy budget (DEB) models
	#' and individual-based ecological simulations.
	#'
	#' @examples
	#' decomposeMassElements(
	#'   dryMass = 10,
	#'   energyTankTraitValue = 0.2,
	#'   betaScaleTank = 0.9
	#' )
	#'
	#' @export
    decomposeMassElements<-function(dryMass, energyTankTraitValue, betaScaleTank){

		energyTank = energyTankTraitValue * dryMass^betaScaleTank
		bodySize = dryMass - energyTank

		return(list(
			energyTank = energyTank,
			bodySize = bodySize
		))
	}

	#' Set Dry Mass of an Organism Accounting for Moulting and Reproduction
	#'
	#' This function calculates the allocation of an organism's dry mass into
	#' structural body mass and energy reserves (energy tank), taking into
	#' account factors such as moulting, reproductive investment, capital
	#' breeding, and excess energy investment.
	#'
	#' @param newDryMass numeric. Proposed new total dry mass for the organism.
	#' @param investment numeric. Amount of mass available for allocation.
	#' @param energyTankTraitValue numeric. Trait scaling factor for the energy tank.
	#' @param mature logical. Whether the organism is mature.
	#' @param hasCapitalBreeding logical. Indicates if the organism can store
	#'        energy for future reproduction (capital breeding).
	#' @param numberOfCapitalBreeds numeric. Number of reproductive events planned.
	#' @param eggsPerBatch numeric. Number of eggs per reproductive batch.
	#' @param eggDryMassAtBirth numeric. Dry mass of a single egg at birth.
	#' @param betaScaleTank numeric. Allometric exponent for scaling energy tank with body mass.
	#' @param assignedForMolt numeric. Fraction of mass/investment assigned for moulting.
	#' @param excessInvestInSize numeric. Fraction of excess investment allocated to body size.
	#' @param isMoulting logical. Whether the organism is currently moulting.
	#' @param checkPreviousValues logical. Whether to adjust mass if it would decrease below previous values.
	#' @param currentBodySize numeric, optional. Current structural body mass.
	#' @param currentEnergyTank numeric, optional. Current energy tank mass.
	#'
	#' @return A list with two numeric elements:
	#' \describe{
	#'   \item{energyTank}{Updated mass allocated to energy reserves.}
	#'   \item{bodySize}{Updated structural body mass.}
	#' }
	#'
	#' @details
	#' The function handles multiple biological scenarios:
	#' \itemize{
	#'   \item If the organism is moulting, only a fraction of dry mass and
	#'         investment is used for normal growth, the rest is reserved for moulting.
	#'   \item Mass allocated for capital breeding is subtracted from the available
	#'         mass before decomposition.
	#'   \item The remaining mass is decomposed into structural body mass and
	#'         energy tank using `decomposeMassElements`.
	#'   \item Excess investment beyond the current dry mass can be partially
	#'         allocated to body size or energy reserves.
	#'   \item Optional checks prevent decreases in body size below previous values.
	#' }
	#'
	#' @examples
	#' setDryMass(
	#'   newDryMass = 10,
	#'   investment = 12,
	#'   energyTankTraitValue = 0.2,
	#'   mature = TRUE,
	#'   hasCapitalBreeding = TRUE,
	#'   numberOfCapitalBreeds = 2,
	#'   eggsPerBatch = 5,
	#'   eggDryMassAtBirth = 0.1,
	#'   betaScaleTank = 0.9,
	#'   assignedForMolt = 0.3,
	#'   excessInvestInSize = 0.5,
	#'   isMoulting = FALSE,
	#'   checkPreviousValues = TRUE,
	#'   currentBodySize = 7,
	#'   currentEnergyTank = 2
	#' )
	#'
	#' @export
	setDryMass<-function(newDryMass, investment, energyTankTraitValue, mature, hasCapitalBreeding, numberOfCapitalBreeds, eggsPerBatch, eggDryMassAtBirth, betaScaleTank, assignedForMolt, excessInvestInSize, isMoulting, checkPreviousValues, currentBodySize=NULL, currentEnergyTank=NULL){

		dryMassToUse = NULL
		investmentToUse = NULL

		if(isMoulting)
		{
			dryMassToUse = newDryMass*assignedForMolt
			investmentToUse = investment*assignedForMolt
		}
		else
		{
			dryMassToUse = newDryMass
			investmentToUse = investment
		}

		excessInvestment = investmentToUse-dryMassToUse
		
		
		massToCapitalBreeding = 0.0

		if(mature & hasCapitalBreeding){
			massToCapitalBreeding = numberOfCapitalBreeds * eggsPerBatch * eggDryMassAtBirth;
		}


		massElements = decomposeMassElements(dryMassToUse - massToCapitalBreeding, energyTankTraitValue, betaScaleTank)

		newEnergyTank = massElements$energyTank
		newCurrentBodySize = massElements$bodySize

		newEnergyTank = newEnergyTank + massToCapitalBreeding


		if(excessInvestment > 0.0)
		{
			newEnergyTank = newEnergyTank + excessInvestment*(1-excessInvestInSize);

			newCurrentBodySize = newCurrentBodySize + excessInvestment*excessInvestInSize;
		}


		if(checkPreviousValues)
		{
			if(newCurrentBodySize < currentBodySize)
			{
				if(dryMassToUse <= currentBodySize)
				{
					newCurrentBodySize = currentBodySize;
					newEnergyTank = 0.0;
				}
				else
				{
					newCurrentBodySize = currentBodySize;
					newEnergyTank = dryMassToUse^betaScaleTank - newCurrentBodySize;
				}
			}
		}


		return(list(
			energyTank = newEnergyTank,
			bodySize = newCurrentBodySize
		))
	}

	#' Calculate Current Clutch Mass and Number of Eggs
	#'
	#' This function computes the mass of a clutch of eggs that an organism
	#' can produce given its current energy reserves. It accounts for both
	#' the base dry mass of the eggs and any additional contribution from the
	#' mother (e.g., maternal investment factor).
	#'
	#' @param currentEnergyTank numeric. The amount of energy currently available for reproduction.
	#' @param targetEggs numeric. The intended number of eggs to produce.
	#' @param eggDryMass numeric. Dry mass of a single egg.
	#' @param factorEggMassFromMom numeric. Fractional contribution of the mother's energy to each egg.
	#'
	#' @return A list with two elements:
	#' \describe{
	#'   \item{currentClutchMass}{The total mass of the eggs the organism can produce.}
	#'   \item{currentNumEggs}{The number of eggs the organism can produce given its current energy.}
	#' }
	#'
	#' @details
	#' The function first calculates the total clutch mass for the target number of eggs,
	#' including the maternal contribution. If the total mass exceeds the available
	#' energy (`currentEnergyTank`), it reduces the number of eggs to the maximum
	#' possible given the energy constraint.
	#'
	#' @examples
	#' calculateCurrentClutchMass(
	#'   currentEnergyTank = 5,
	#'   targetEggs = 10,
	#'   eggDryMass = 0.4,
	#'   factorEggMassFromMom = 0.1
	#' )
	#'
	#' @export
	calculateCurrentClutchMass<-function(currentEnergyTank, targetEggs, eggDryMass, factorEggMassFromMom){

		clutchMass = targetEggs*(eggDryMass + eggDryMass*factorEggMassFromMom)

		if(clutchMass < currentEnergyTank) {
			return(list(
				currentClutchMass = clutchMass,
				currentNumEggs = targetEggs
			))
		} else {
			currentNumEggs = floor(currentEnergyTank/(eggDryMass + eggDryMass*factorEggMassFromMom))

			return(list(
				currentClutchMass = currentNumEggs*(eggDryMass + eggDryMass*factorEggMassFromMom),
				currentNumEggs = currentNumEggs
			))
		}
	}
	
	#' Calculate Reproduction Target for an Individual
	#'
	#' This function computes the target reproductive parameters for an individual,
	#' including the dry mass at the next reproduction event, the age at that event,
	#' the clutch mass, and the number of eggs. It accounts for different reproductive
	#' strategies such as capital breeding, indeterminate growth, and size-dependent
	#' fecundity.
	#'
	#' @param capitalBreeding logical. Whether the organism follows a capital breeding strategy.
	#' @param indeterminateGrowth logical. Whether the organism grows continuously after maturation.
	#' @param currentDryMass numeric. Current dry mass of the individual.
	#' @param currentAge numeric. Current age of the individual.
	#' @param eggsPerBatchFromEquation logical. Whether the number of eggs per batch is calculated from a linear equation based on body mass.
	#' @param eggsPerBatch numeric. Default number of eggs per batch.
	#' @param eggDryMass numeric. Dry mass of a single egg.
	#' @param factorEggMassFromMom numeric. Fractional contribution of the mother's energy to each egg.
	#' @param interceptForEggBatchFromEquation numeric. Intercept of the linear equation for egg batch size.
	#' @param slopeForEggBatchFromEquation numeric. Slope of the linear equation for egg batch size.
	#' @param femaleMaxReproductionEvents numeric. Maximum number of reproductive events for the female.
	#' @param timeOfReproEvent numeric. Time interval between reproduction events.
	#' @param massesVector numeric vector. Dry masses used to calculate reproductive allocation for indeterminate growth.
	#' @param massAtMaturation numeric. Dry mass at the time of maturation.
	#' @param reproCounter numeric. Number of reproduction events already performed.
	#' @param timeOfReproEventDuringCapitalBreeding numeric. Time between reproduction events for capital breeders.
	#' @param tmax numeric. Maximum age for growth calculations.
	#' @param Lmax numeric. Maximum length used in growth curve calculations.
	#' @param type character. Type of growth curve (used in `growthCurve`).
	#' @param A numeric. Growth curve parameter A.
	#' @param coefficientForMassA numeric. Parameter A used in dry mass calculation from length.
	#' @param scaleForMassB numeric. Parameter B used in dry mass calculation from length.
	#' @param coefficientForMassAforMature numeric. Parameter A used in dry mass calculation for mature individuals.
	#' @param scaleForMassBforMature numeric. Parameter B used in dry mass calculation for mature individuals.
	#' @param growth numeric. Growth rate parameter.
	#' @param mature logical. Whether the individual is mature.
	#' @param instar numeric. Current instar or developmental stage of the individual.
	#' @param maxInstar numeric. Maximum instar of the species.
	#' @param conversionToWetMass numeric. Conversion factor from dry mass to wet mass.
	#'
	#' @return A list with the following elements:
	#' \describe{
	#'   \item{massForNextReproduction}{Dry mass of the individual at the next reproduction event, including clutch mass.}
	#'   \item{ageForNextReproduction}{Age at the next reproduction event.}
	#'   \item{clutchMass}{Mass of the eggs produced in the next reproductive event.}
	#'   \item{targetEggs}{Number of eggs targeted for the next reproductive event.}
	#' }
	#'
	#' @details
	#' - For capital breeders, the next reproduction mass is the current dry mass plus
	#'   any mass allocated to eggs. The number of eggs can be calculated from a fixed
	#'   batch size or a linear equation based on current wet mass.
	#' - For indeterminate growers, reproductive allocation considers the remaining growth
	#'   potential and distributes eggs across multiple events.
	#' - The function handles both cases where reproduction is size-dependent or time-dependent.
	#'
	#' @examples
	#' calculateReproTarget(
	#'   capitalBreeding = TRUE,
	#'   indeterminateGrowth = FALSE,
	#'   currentDryMass = 5,
	#'   currentAge = 10,
	#'   eggsPerBatchFromEquation = TRUE,
	#'   eggsPerBatch = 20,
	#'   eggDryMass = 0.4,
	#'   factorEggMassFromMom = 0.1,
	#'   interceptForEggBatchFromEquation = 5,
	#'   slopeForEggBatchFromEquation = 0.2,
	#'   femaleMaxReproductionEvents = 5,
	#'   timeOfReproEvent = 2,
	#'   massesVector = c(3, 4, 5, 6, 7),
	#'   massAtMaturation = 5,
	#'   reproCounter = 0,
	#'   timeOfReproEventDuringCapitalBreeding = 2,
	#'   tmax = 20,
	#'   Lmax = 10,
	#'   type = "logistic",
	#'   A = 1,
	#'   coefficientForMassA = 0.1,
	#'   scaleForMassB = 2,
	#'   coefficientForMassAforMature = 0.1,
	#'   scaleForMassBforMature = 2,
	#'   growth = 0.05,
	#'   mature = TRUE,
	#'   instar = 3,
	#'   maxInstar = 5,
	#'   conversionToWetMass = 1.2
	#' )
	#'
	#' @export
	calculateReproTarget<-function(capitalBreeding, indeterminateGrowth, currentDryMass, currentAge, eggsPerBatchFromEquation, 
			eggsPerBatch, eggDryMass, factorEggMassFromMom, interceptForEggBatchFromEquation, slopeForEggBatchFromEquation,
			femaleMaxReproductionEvents, timeOfReproEvent, massesVector, massAtMaturation, reproCounter, timeOfReproEventDuringCapitalBreeding,
			tmax, Lmax, type, A, coefficientForMassA, scaleForMassB, coefficientForMassAforMature, scaleForMassBforMature, growth, mature, instar, maxInstar, conversionToWetMass){

		massForNextReproduction <- NA
		ageForNextReproduction <- NA
		clutchMass <- NA


		if(capitalBreeding){

			massForNextReproduction = currentDryMass

			if(reproCounter == 0){
				ageForNextReproduction = currentAge
			}
			else{
				ageForNextReproduction = currentAge+timeOfReproEventDuringCapitalBreeding
			}
			
			

			if(eggsPerBatchFromEquation){

				currentWetMass = currentDryMass*conversionToWetMass	
				newTargetEggs = interceptForEggBatchFromEquation + slopeForEggBatchFromEquation*currentWetMass  

			}else{

				newTargetEggs = eggsPerBatch

			}

			clutchMass = newTargetEggs*(eggDryMass + eggDryMass*factorEggMassFromMom) 

		}
		else{
			if(indeterminateGrowth){

				totFec = femaleMaxReproductionEvents*eggsPerBatch
				totalReproMass = sum(massesVector[(length(massesVector)-femaleMaxReproductionEvents+1):length(massesVector)])
				
				
				ageForNextReproduction = currentAge+timeOfReproEvent

				
									
				fractFirstRepro = massesVector[(length(massesVector)-femaleMaxReproductionEvents+1)]/totalReproMass
				
				newTargetEggs = fractFirstRepro*totFec
				
				clutchMass = newTargetEggs*(eggDryMass + eggDryMass*factorEggMassFromMom) 
				
				if(instar == maxInstar){
					
					massForNextReproduction = massAtMaturation + clutchMass

				}else{

					if(ageForNextReproduction >= tmax){
						nextLength = growthCurve(Lmax=Lmax,
							k=growth,t=tmax*timeStep,
							tmax=tmax*timeStep,eggDryMass = eggDryMass, A = A, 
							type = type, coefficientForMassA, scaleForMassB)
					}else{
						nextLength = growthCurve(Lmax=Lmax,
							k=growth,t=ageForNextReproduction*timeStep,
							tmax=tmax*timeStep,eggDryMass = eggDryMass, A = A, 
							type = type, coefficientForMassA, scaleForMassB)
					}
					

					massForNextReproduction<-calculateDryMass(nextLength, coefficientForMassAforMature, scaleForMassBforMature) + clutchMass
				}
			}else{

				if(eggsPerBatchFromEquation){

					currentWetMass = massAtMaturation*conversionToWetMass	
					newTargetEggs = interceptForEggBatchFromEquation + slopeForEggBatchFromEquation*currentWetMass 

				}else{

					newTargetEggs = eggsPerBatch

				}

				clutchMass = newTargetEggs*(eggDryMass + eggDryMass*factorEggMassFromMom) 

				massForNextReproduction = massAtMaturation + clutchMass
				
				ageForNextReproduction = currentAge+timeOfReproEvent
			}
		}

		return(list(massForNextReproduction=massForNextReproduction, ageForNextReproduction=ageForNextReproduction, 
			clutchMass=clutchMass, targetEggs=newTargetEggs))
	}

	#' Check and Update Reproduction Target for an Individual
	#'
	#' This function checks whether an individual is ready to reproduce based on its current age
	#' and reproduction schedule, and updates reproductive parameters accordingly. It handles
	#' both capital and non-capital breeding strategies, as well as indeterminate growth.
	#'
	#' @param reproCounter numeric. Number of reproduction events already performed.
	#' @param numberOfCapitalBreeds numeric. Maximum number of reproduction events for capital breeders.
	#' @param femaleMaxReproductionEvents numeric. Maximum number of reproductive events for the female.
	#' @param currentDryMass numeric. Current dry mass of the individual.
	#' @param currentEnergyTank numeric. Current energy stored in the individual.
	#' @param currentAge numeric. Current age of the individual.
	#' @param capitalBreeding logical. Whether the organism is currently in capital breeding mode.
	#' @param massAtMaturation numeric. Dry mass at maturation.
	#' @param instar numeric. Current developmental stage.
	#' @param maxInstar numeric. Maximum developmental stage.
	#' @param massForNextReproduction numeric. Dry mass at next reproduction event.
	#' @param ageForNextReproduction numeric. Age at next reproduction event.
	#' @param targetEggs numeric. Number of eggs targeted for the next reproduction event.
	#' @param indeterminateGrowth logical. Whether the organism grows continuously after maturation.
	#' @param eggsPerBatchFromEquation logical. Whether the number of eggs per batch is size-dependent.
	#' @param eggsPerBatch numeric. Default number of eggs per batch.
	#' @param eggDryMass numeric. Dry mass of a single egg.
	#' @param factorEggMassFromMom numeric. Fractional contribution of the mother to egg mass.
	#' @param interceptForEggBatchFromEquation numeric. Intercept of linear egg batch equation.
	#' @param slopeForEggBatchFromEquation numeric. Slope of linear egg batch equation.
	#' @param timeOfReproEvent numeric. Time between reproduction events.
	#' @param massesVector numeric vector. Vector of dry masses for reproductive allocation.
	#' @param timeOfReproEventDuringCapitalBreeding numeric. Interval between reproduction events for capital breeders.
	#' @param tmax numeric. Maximum age for growth curve calculations.
	#' @param Lmax numeric. Maximum length used in growth curve.
	#' @param type character. Type of growth curve.
	#' @param A numeric. Parameter for growth curve.
	#' @param coefficientForMassA numeric. Parameter A for dry mass calculation from length.
	#' @param scaleForMassB numeric. Parameter B for dry mass calculation from length.
	#' @param coefficientForMassAforMature numeric. Parameter A for mature individuals in dry mass calculation.
	#' @param scaleForMassBforMature numeric. Parameter B for mature individuals in dry mass calculation.
	#' @param growth numeric. Growth rate.
	#' @param mature logical. Whether the individual is mature.
	#' @param conversionToWetMass numeric. Conversion factor from dry mass to wet mass.
	#'
	#' @return A list containing updated reproductive parameters:
	#' \describe{
	#'   \item{reproCounter}{Updated number of reproduction events performed.}
	#'   \item{currentDryMass}{Updated dry mass after egg allocation.}
	#'   \item{currentEnergyTank}{Updated energy tank after egg allocation.}
	#'   \item{capitalBreeding}{Updated capital breeding status.}
	#'   \item{massAtMaturation}{Updated dry mass at maturation if capital breeding ended.}
	#'   \item{massForNextReproduction}{Dry mass at the next reproduction event.}
	#'   \item{ageForNextReproduction}{Age at the next reproduction event.}
	#'   \item{clutchMass}{Mass of the eggs produced in this reproduction event.}
	#'   \item{targetEggs}{Number of eggs targeted for this reproduction event.}
	#'   \item{numEggs}{Number of eggs actually produced.}
	#' }
	#'
	#' @details
	#' - If the individual is ready to reproduce (age >= ageForNextReproduction), the function
	#'   calculates the current clutch mass and updates body mass and energy tank.
	#' - Capital breeders may switch off capital breeding mode after completing the allowed
	#'   number of capital reproduction events.
	#' - The function calls `calculateCurrentClutchMass` and `calculateReproTarget` to determine
	#'   egg allocation and the target mass and age for the next reproduction event.
	#'
	#' @export
	checkReproTarget<-function(reproCounter, numberOfCapitalBreeds, femaleMaxReproductionEvents, currentDryMass, currentEnergyTank, currentAge, capitalBreeding, 
			massAtMaturation, instar, maxInstar, massForNextReproduction, ageForNextReproduction, targetEggs,
			indeterminateGrowth, eggsPerBatchFromEquation, eggsPerBatch, eggDryMass, factorEggMassFromMom, 
			interceptForEggBatchFromEquation, slopeForEggBatchFromEquation, timeOfReproEvent, massesVector,
			timeOfReproEventDuringCapitalBreeding, tmax, Lmax, type, A, coefficientForMassA, scaleForMassB, coefficientForMassAforMature, scaleForMassBforMature, growth, mature, conversionToWetMass){

		newTargetEggs <- NA
		newClutchMass <- NA
		numEggs <- NA

		if(capitalBreeding){
			if(ageForNextReproduction <= currentAge){
					
				reproCounter = reproCounter + 1

				result <- calculateCurrentClutchMass(currentEnergyTank, targetEggs, eggDryMass, factorEggMassFromMom)

				finalClutchMass <- result$currentClutchMass
				finalNumEggs <-  result$currentNumEggs

				numEggs <- finalNumEggs


				currentDryMass = currentDryMass - finalClutchMass
				currentEnergyTank = currentEnergyTank - finalClutchMass


				if(reproCounter >= numberOfCapitalBreeds){

					capitalBreeding = FALSE

					massAtMaturation = currentDryMass

				}


				if(reproCounter < femaleMaxReproductionEvents)
				{
					reproTarget <- calculateReproTarget( capitalBreeding=capitalBreeding, indeterminateGrowth=indeterminateGrowth, 
						currentDryMass=currentDryMass, currentAge=currentAge, eggsPerBatchFromEquation=eggsPerBatchFromEquation, 
						eggsPerBatch=eggsPerBatch, eggDryMass=eggDryMass, factorEggMassFromMom=factorEggMassFromMom, 
						interceptForEggBatchFromEquation=interceptForEggBatchFromEquation, slopeForEggBatchFromEquation=slopeForEggBatchFromEquation,
						femaleMaxReproductionEvents=femaleMaxReproductionEvents, timeOfReproEvent=timeOfReproEvent, massesVector=massesVector, 
						massAtMaturation=massAtMaturation, reproCounter=reproCounter, timeOfReproEventDuringCapitalBreeding=timeOfReproEventDuringCapitalBreeding,
						tmax=tmax, Lmax=Lmax, type=type, A=A, coefficientForMassA=coefficientForMassA, 
						scaleForMassB=scaleForMassB, coefficientForMassAforMature=coefficientForMassAforMature, scaleForMassBforMature=scaleForMassBforMature, 
						growth=growth, mature=mature, instar=instar, maxInstar=maxInstar, conversionToWetMass=conversionToWetMass)

					massForNextReproduction = reproTarget$massForNextReproduction
					ageForNextReproduction = reproTarget$ageForNextReproduction
					newClutchMass = reproTarget$clutchMass
					newTargetEggs = reproTarget$targetEggs

				}
			}
		}else{
			if(ageForNextReproduction <= currentAge){
				
				reproCounter = reproCounter + 1
				

				result <- calculateCurrentClutchMass(currentEnergyTank, targetEggs, eggDryMass, factorEggMassFromMom)

				finalClutchMass <- result$currentClutchMass
				finalNumEggs <-  result$currentNumEggs

				numEggs <- finalNumEggs


				currentDryMass = currentDryMass - finalClutchMass
				currentEnergyTank = currentEnergyTank - finalClutchMass


				if(reproCounter < femaleMaxReproductionEvents)
				{
					reproTarget <- calculateReproTarget(capitalBreeding=capitalBreeding, indeterminateGrowth=indeterminateGrowth, 
						currentDryMass=currentDryMass, currentAge=currentAge, eggsPerBatchFromEquation=eggsPerBatchFromEquation, 
						eggsPerBatch=eggsPerBatch, eggDryMass=eggDryMass, factorEggMassFromMom=factorEggMassFromMom, 
						interceptForEggBatchFromEquation=interceptForEggBatchFromEquation, slopeForEggBatchFromEquation=slopeForEggBatchFromEquation,
						femaleMaxReproductionEvents=femaleMaxReproductionEvents, timeOfReproEvent=timeOfReproEvent, massesVector=massesVector, 
						massAtMaturation=massAtMaturation, reproCounter=reproCounter, timeOfReproEventDuringCapitalBreeding=timeOfReproEventDuringCapitalBreeding,
						tmax=tmax, Lmax=Lmax, type=type, A=A, coefficientForMassA=coefficientForMassA, 
						scaleForMassB=scaleForMassB, coefficientForMassAforMature=coefficientForMassAforMature, scaleForMassBforMature=scaleForMassBforMature, 
						growth=growth, mature=mature, instar=instar, maxInstar=maxInstar, conversionToWetMass=conversionToWetMass)

					massForNextReproduction = reproTarget$massForNextReproduction
					ageForNextReproduction = reproTarget$ageForNextReproduction
					newClutchMass = reproTarget$clutchMass
					newTargetEggs = reproTarget$targetEggs

				}

			}
		}

		return(list(reproCounter=reproCounter, currentDryMass=currentDryMass, currentEnergyTank=currentEnergyTank, capitalBreeding=capitalBreeding, massAtMaturation=massAtMaturation, massForNextReproduction=massForNextReproduction, ageForNextReproduction=ageForNextReproduction, clutchMass=newClutchMass, targetEggs=newTargetEggs, numEggs=numEggs))
	}

	#' Predict Next Dry Mass of an Individual
	#'
	#' This function predicts the dry mass of an individual at the next time step, considering
	#' its current age, maturation status, growth, and reproductive strategy. It accounts for
	#' capital breeding, reproduction targets, and pre-maturation growth.
	#'
	#' @param mature logical. Whether the individual is mature.
	#' @param currentDryMass numeric. Current dry mass of the individual.
	#' @param ageOfFirstMaturation numeric. Age at first maturation.
	#' @param pupaPeriodTime numeric. Duration of the pupa period.
	#' @param currentAge numeric. Current age of the individual.
	#' @param nextAge numeric. Age at the next time step.
	#' @param Lmax numeric. Maximum length used in the growth curve.
	#' @param eggDryMass numeric. Dry mass of a single egg.
	#' @param type character. Type of growth curve.
	#' @param A numeric. Parameter for growth curve.
	#' @param tmax numeric. Maximum age for growth curve calculations.
	#' @param growth numeric. Growth rate constant.
	#' @param coefficientForMassA numeric. Parameter A for dry mass calculation from length.
	#' @param scaleForMassB numeric. Parameter B for dry mass calculation from length.
	#' @param capitalBreeding logical. Whether the individual is currently in capital breeding mode.
	#' @param reproCounter numeric. Number of reproduction events already performed.
	#' @param femaleMaxReproductionEvents numeric. Maximum number of reproduction events for the female.
	#' @param massForNextReproduction numeric. Dry mass at the next reproduction event.
	#' @param ageForNextReproduction numeric. Age at the next reproduction event.
	#'
	#' @return numeric. Predicted dry mass of the individual at `nextAge`.
	#'
	#' @details
	#' - If the individual is mature:
	#'   - And has completed all reproduction events, the mass remains unchanged.
	#'   - If in capital breeding mode, mass remains constant until reproduction occurs.
	#'   - Otherwise, mass is linearly interpolated toward the next reproduction mass if it is higher than the current mass.
	#' - If the individual is immature:
	#'   - Before maturation (excluding pupa period), mass is predicted using a growth curve.
	#'   - During the pupa stage, mass remains constant.
	#'
	#' @export
	calculateNextMassPredicted<-function(mature, currentDryMass, ageOfFirstMaturation, pupaPeriodTime, currentAge, nextAge, Lmax, eggDryMass, type, A, tmax, 
			growth, coefficientForMassA, scaleForMassB, capitalBreeding, reproCounter, femaleMaxReproductionEvents,
			massForNextReproduction, ageForNextReproduction){

		nextMassPredicted<-NA
		
		if(mature){
			if(reproCounter == femaleMaxReproductionEvents){

				nextMassPredicted = currentDryMass

			}
			else{
				if(capitalBreeding){

					nextMassPredicted = currentDryMass
					
				}
				else{
					if(massForNextReproduction > currentDryMass & ageForNextReproduction > currentAge){

						slopeTarget = (massForNextReproduction - currentDryMass)/(ageForNextReproduction-currentAge)
						interceptTarget = currentDryMass-slopeTarget*currentAge
						nextMassPredicted = interceptTarget + slopeTarget*nextAge

					}else{

						nextMassPredicted = currentDryMass

					}
				}
			}
		}else{
			if(currentAge < ageOfFirstMaturation-round(pupaPeriodTime / timeStep)){
				nextLength = growthCurve(Lmax=Lmax,
					k=growth,t=nextAge*timeStep,
					tmax=tmax*timeStep,eggDryMass = eggDryMass, A = A, 
					type = type, coefficientForMassA, scaleForMassB)

				nextMassPredicted = calculateDryMass(nextLength, coefficientForMassA, scaleForMassB)
			}else{
				nextMassPredicted = currentDryMass
			}
		}

		return(nextMassPredicted)
	}

	#' Calculate Total Metabolic Dry Mass Loss
	#'
	#' This function calculates the total metabolic dry mass loss of an individual
	#' over a given time step, considering basal and field metabolic rates, 
	#' temperature, activity, and simulation type (e.g., dinosaurs or other species).
	#'
	#' @param wetMass numeric. Wet mass of the individual (kg).
	#' @param bMet numeric. Basal metabolic rate scaling exponent or parameter(s).
	#' @param actE_met numeric. Activation energy for metabolism (eV).
	#' @param temperature numeric. Ambient temperature (°C).
	#' @param proportionOfTimeTheAnimalWasMoving numeric. Proportion of the time the animal was active/moving (0–1).
	#' @param search_area numeric. Area searched by the animal during the time step (m²).
	#' @param simulationType character. Type of simulation, e.g., `"Dinosaurs"` or other species.
	#' @param tempFromLab numeric. Laboratory reference temperature (°C) used in metabolic calculations.
	#' @param conversionToWetMass numeric. Conversion factor from wet mass to dry mass.
	#' @param multiplierForFieldMetabolicRate numeric. Multiplier for field metabolic rate (FMR) relative to basal metabolic rate (BMR).
	#' @param timeStep numeric. Duration of the simulation time step (days).
	#'
	#' @return numeric. Total metabolic dry mass loss during the time step (kg dry mass).
	#'
	#' @details
	#' The calculation depends on the `simulationType`:
	#' - For `"Dinosaurs"`, BMR and FMR are calculated using empirical scaling equations, 
	#'   adjusted for activity and movement distance. Both are converted to dry mass loss.
	#' - For other species, BMR is temperature-dependent and follows an Arrhenius-type equation. 
	#'   A field metabolic rate adjustment is applied based on the proportion of time moving.
	#'   Small animals (<5.2 kg) receive an additional scaling correction.
	#' - Both BMR and FMR are normalized to daily rates and scaled to the simulation `timeStep`.
	#'
	#' @export
	getTotalMetabolicDryMassLoss<-function(wetMass, bMet, actE_met, temperature, proportionOfTimeTheAnimalWasMoving, search_area, simulationType, tempFromLab, conversionToWetMass, multiplierForFieldMetabolicRate, timeStep)
	{
        BOLTZMANN = 8.62E-5

		totalMetabolicDryMassLoss = 0

		if(simulationType %in% "Dinosaurs") {
		
			basalMetabolicTax = 0.002*(wetMass*1000)^bMet[1]

			basalMetabolicTax = basalMetabolicTax 
			
			distanceMoved = proportionOfTimeTheAnimalWasMoving*search_area  
			
			speedOfTravel = distanceMoved*(1000/(3600*24)) 
			
			field_met_tax = speedOfTravel*(10.7*wetMass^0.68) 
			
			loss_from_bmr = basalMetabolicTax*24*3600
			loss_from_fmr = field_met_tax

			loss_from_bmr=loss_from_bmr/7
			loss_from_fmr=loss_from_fmr/7
			totalMetabolicDryMassLoss = ((loss_from_bmr + loss_from_fmr)*0.000001) / conversionToWetMass
			totalMetabolicDryMassLoss=totalMetabolicDryMassLoss*timeStep
		}else{
			
			basalMetabolicTax = exp(-7.2945+43.966*actE_met+bMet*log(wetMass)-actE_met*(1/((temperature+273.15)*BOLTZMANN)))
			
			if(wetMass < 5.2){
				basalMetabolicTax = exp(-2.605722)*basalMetabolicTax^0.7961851 
			}

			basalMetabolicTax = basalMetabolicTax
			loss_from_bmr = (1-proportionOfTimeTheAnimalWasMoving)*basalMetabolicTax*24
			field_met_tax = multiplierForFieldMetabolicRate*basalMetabolicTax
			loss_from_fmr = proportionOfTimeTheAnimalWasMoving*field_met_tax*24

			loss_from_bmr=loss_from_bmr/7
			loss_from_fmr=loss_from_fmr/7
			totalMetabolicDryMassLoss = (loss_from_bmr + loss_from_fmr) / conversionToWetMass
			totalMetabolicDryMassLoss=totalMetabolicDryMassLoss*timeStep
		}

		return(totalMetabolicDryMassLoss)
	}

	#' Calculate Previous Target Mass for an Individual
	#'
	#' Determines the mass of an individual at the beginning of the current time step
	#' relative to its previous instar or the start of a reproduction event.
	#' This function is primarily used for tracking mass targets in females during
	#' reproduction events.
	#'
	#' @param actualTimeStep integer. Index of the current time step in the simulation.
	#' @param capta_all list. A list containing the individual's state variables over time,
	#'   including `mature`, `reproCounter`, `massAtPreviousInstar`, `currentDryMass`, 
	#'   and `actualMassAtTheBeginningOfReproEvent`.
	#' @param individual list. A list representing the individual, must contain `gender` 
	#'   ("FEMALE", "MALE", or "HERMAPHRODITE").
	#'
	#' @return numeric. The mass of the individual at the beginning of the time step.
	#'
	#' @details
	#' - If the individual is mature and female:
	#'   - If no reproduction has occurred yet (`reproCounter == 0`), returns the mass 
	#'     at the previous instar.
	#'   - If a reproduction has occurred, updates and returns the mass at the beginning 
	#'     of the reproduction event.
	#' - For males and hermaphrodites, the function currently stops with "Not implemented".
	#' - If the individual is not mature, returns the mass at the previous instar.
	#'
	#' @export
	calculatePreviousTarget<-function(actualTimeStep, capta_all, individual)
	{
		if(capta_all$mature[actualTimeStep])
		{
			if(individual$gender == "FEMALE")
			{
				if(capta_all$reproCounter[actualTimeStep] == 0)
				{
					return(capta_all$massAtPreviousInstar[actualTimeStep])
				}
				else
				{
					if(capta_all$reproCounter[actualTimeStep] != capta_all$reproCounter[actualTimeStep-1]){
						capta_all$actualMassAtTheBeginningOfReproEvent[actualTimeStep]<-capta_all$currentDryMass[actualTimeStep]
					}

					return(capta_all$actualMassAtTheBeginningOfReproEvent[actualTimeStep])
				}
			}
			else if(individual$gender == "MALE"){
				stop("Not implemented")
			}
			else if(individual$gender == "HERMAPHRODITE"){
				stop("Not implemented")
			}
		}
		else
		{
			return(capta_all$massAtPreviousInstar[actualTimeStep])
		}
	}

	#' Calculate Next Target Mass for an Individual
	#'
	#' Determines the target mass of an individual for the next time step in the simulation.
	#' For mature females, this corresponds to the mass for the next reproduction event.
	#' For immature individuals, it returns the final mass of the current instar.
	#'
	#' @param actualTimeStep integer. Index of the current time step in the simulation.
	#' @param capta_all list. A list containing the individual's state variables over time,
	#'   including `mature`, `massForNextReproduction`, and `instar`.
	#' @param individual list. A list representing the individual, must contain `gender` 
	#'   ("FEMALE", "MALE", or "HERMAPHRODITE") and `finalMassesVector` (vector of target masses per instar).
	#'
	#' @return numeric. The predicted target mass for the individual at the next time step.
	#'
	#' @details
	#' - If the individual is mature and female, returns the mass for the next reproduction.
	#' - For males and hermaphrodites, the function currently stops with "Not implemented".
	#' - If the individual is not mature, returns the final mass associated with the current instar.
	#'
	#' @export
	calculateNextTarget<-function(actualTimeStep, capta_all, individual)
	{
		if(capta_all$mature[actualTimeStep])
		{
			if(individual$gender == "FEMALE")
			{
				return(capta_all$massForNextReproduction[actualTimeStep])
			}
			else if(individual$gender == "MALE"){
				stop("Not implemented")
			}
			else if(individual$gender == "HERMAPHRODITE"){
				stop("Not implemented")
			}
		}
		else
		{
			return(individual$finalMassesVector[capta_all$instar[actualTimeStep]]);
		}
	}

	#' Calculate Relative Progress Toward Next Mass Target
	#'
	#' Computes the relative progress \(h\) of an individual toward its next target mass.
	#' This value is used to determine growth allocation between body mass and energy storage.
	#'
	#' @param actualTimeStep integer. Index of the current time step in the simulation.
	#' @param capta_all list. A list containing the individual's state variables over time, including
	#'   `currentAge`, `currentDryMass`, `capitalBreeding`, and `instar`.
	#' @param individual list. A list representing the individual, must contain `gender` and
	#'   `finalMassesVector`.
	#'
	#' @return numeric. Relative progress \(h\) toward the next target mass, in the range [0, 1].
	#'
	#' @details
	#' - If the individual is in a capital breeding state, \(h\) is set to 0.
	#' - If the next target mass is equal to the previous target mass, \(h\) is 0.
	#' - Otherwise, \(h\) is calculated as 
	#'   \[
	#'   h = 1 - \frac{\text{currentDryMass} - \text{previousTarget}}{\text{nextTarget} - \text{previousTarget}}
	#'   \]
	#'   and is clamped to a minimum of 0.
	#' - If `actualTimeStep` is the last time step, \(h\) is set to 0.
	#'
	#' @seealso calculatePreviousTarget, calculateNextTarget
	#'
	#' @export
	calculateH<-function(actualTimeStep, capta_all, individual)
	{
		h = 0.0

		if(actualTimeStep != length(capta_all$currentAge))
		{
			if(capta_all$capitalBreeding[actualTimeStep])
			{
				h = 0.0
			}
			else
			{
				previousTarget = calculatePreviousTarget(actualTimeStep=actualTimeStep, capta_all=capta_all, individual=individual)
				nextTarget = calculateNextTarget(actualTimeStep=actualTimeStep, capta_all=capta_all, individual=individual)
			
				if(nextTarget == previousTarget)
				{
					h = 0.0
				}
				else
				{
					h = 1-(capta_all$currentDryMass[actualTimeStep]-previousTarget)/(nextTarget-previousTarget)

					if(h < 0)
					{
						h = 0.0
					}
				}
			}
		}

		return(h)
	}

	#' Apply Allometric Scaling Model
	#'
	#' Computes a scaled trait value based on an individual's dry mass using an allometric equation.
	#'
	#' @param dryMass numeric. The dry mass of the individual.
	#' @param coefficient numeric. The allometric coefficient.
	#' @param scale numeric. The allometric exponent (scaling factor).
	#'
	#' @return numeric. The trait value after applying the allometric scaling.
	#'
	#' @details
	#' The function applies a standard allometric model:
	#' \[
	#' \text{traitValue} = \text{coefficient} \times (\text{dryMass}^{\text{scale}})
	#' \]
	#' where `coefficient` adjusts the magnitude and `scale` determines how the trait
	#' scales with body mass.
	#'
	#' @examples
	#' applyAllometricModel(dryMass = 10, coefficient = 0.5, scale = 0.75)
	#'
	#' @export
	applyAllometricModel<-function(dryMass, coefficient, scale)
	{
		return(coefficient * (dryMass^scale))
	}

	#' Apply Condition-Dependent Plasticity to a Trait
	#'
	#' Adjusts a trait value based on an individual's condition using a plasticity model.
	#'
	#' @param traitValue numeric. The original trait value to be modified.
	#' @param plasticityDueToCondition numeric. The plasticity coefficient representing
	#'   how strongly the trait responds to the individual's condition.
	#' @param h numeric. The relative distance between the current state and the target
	#'   state, usually ranging from 0 to 1.
	#'
	#' @return numeric. The adjusted trait value accounting for condition-dependent plasticity.
	#'
	#' @details
	#' The function applies a standard plasticity model:
	#' \[
	#' \text{adjustedTrait} = \text{traitValue} \times \left( 1 - \exp(-\text{plasticityDueToCondition} \cdot h) \right)
	#' \]
	#' where the trait increases as the individual's condition approaches the target value.
	#'
	#' @examples
	#' applyPlasticityDueToConditionToTrait(traitValue = 10, plasticityDueToCondition = 0.5, h = 0.8)
	#'
	#' @export
	applyPlasticityDueToConditionToTrait<-function(traitValue, plasticityDueToCondition, h)
	{
		return(traitValue*(1-exp(-plasticityDueToCondition*h)))
	}

	#' Calculate Post-Transformation Speed
	#'
	#' Adjusts the predicted speed of an individual after applying allometric scaling,
	#' based on the type of simulation and body mass.
	#'
	#' @param simulationType character. The type of simulation or organism, e.g., "Aquatic", "Arthropods", "Dinosaurs".
	#' @param speedAfterAllometric numeric. The speed predicted from the allometric model before adjustment.
	#' @param wetMass numeric. The wet body mass of the individual (in appropriate units, typically kg).
	#'
	#' @return numeric. The adjusted speed after considering post-allometric effects.
	#'
	#' @details
	#' For "Aquatic" simulations, the speed is returned directly from the allometric model.
	#' For "Arthropods" and "Dinosaurs", the speed is adjusted using the formula:
	#' \[
	#' v = v_\text{allometric} \times \left(1 - \exp\left(-22 \cdot \text{wetMass}^{-0.6}\right)\right)
	#' \]
	#' This follows the model described by Hirt et al. (2017) to account for body-mass dependent scaling of speed.
	#'
	#' @examples
	#' calculatePostTSpeed("Dinosaurs", speedAfterAllometric = 10, wetMass = 500)
	#'
	#' @export
	calculatePostTSpeed<-function(simulationType, speedAfterAllometric, wetMass)
	{
		if(simulationType %in% c("Aquatic")){
			return(speedAfterAllometric)
		}

		if(simulationType %in% c("Arthropods","Dinosaurs")){
			return(speedAfterAllometric*(1-exp(-22*(wetMass^(-0.6))))) 
		}
	}

	#' Calculate Pre-Final Voracity (Limited)
	#'
	#' Limits the predicted voracity of an individual by the target mass.
	#'
	#' @param targetMasses numeric. The target mass that the individual aims to consume.
	#' @param predVor numeric. The predicted voracity based on traits or models.
	#'
	#' @return numeric. The limited voracity, taking the minimum between target mass and predicted voracity.
	#'
	#' @details
	#' This function ensures that the individual's voracity does not exceed the target mass.
	#' It is typically used as a preliminary step before computing final consumption or intake rates.
	#'
	#' @examples
	#' calculatePreFinalVoracityLimited(targetMasses = 5, predVor = 7) # Returns 5
	#' calculatePreFinalVoracityLimited(targetMasses = 10, predVor = 7) # Returns 7
	#'
	#' @export
	calculatePreFinalVoracityLimited<-function(targetMasses, predVor)
	{
		return(min(targetMasses,predVor))
	}

	#' Calculate Pre-Final Voracity (Unlimited)
	#'
	#' Returns the predicted voracity of an individual without any limitation by target mass.
	#'
	#' @param targetMasses numeric. The target mass that the individual aims to consume (not used in this function).
	#' @param predVor numeric. The predicted voracity based on traits or models.
	#'
	#' @return numeric. The predicted voracity, returned as is without limitation.
	#'
	#' @details
	#' Unlike `calculatePreFinalVoracityLimited`, this function does not restrict the voracity
	#' by the target mass. It is used in models where consumption is allowed to exceed target mass.
	#'
	#' @examples
	#' calculatePreFinalVoracityUnlimited(targetMasses = 5, predVor = 7) # Returns 7
	#' calculatePreFinalVoracityUnlimited(targetMasses = 10, predVor = 7) # Returns 7
	#'
	#' @export
	calculatePreFinalVoracityUnlimited<-function(targetMasses, predVor)
	{
		return(predVor)
	}

	#' Simulate the Life History of an Individual
	#'
	#' This function simulates the growth, metabolism, reproduction, and behavior of a single individual 
	#' over its lifetime, based on its traits, life stage, and environmental interactions.
	#'
	#' @param individual list. A list containing all individual-specific parameters and traits, 
	#'   including age vectors, growth parameters, reproduction parameters, allometric coefficients, 
	#'   and behavioral traits.
	#' @param preFinalVoracityFunction function. A function to compute the pre-final voracity of the 
	#'   individual, which can be limited or unlimited.
	#' @param todayEncountersWithPredators numeric. Number of predator encounters for the individual 
	#'   on the current day.
	#' @param maxEncountersPerDayInPop numeric. Maximum number of predator encounters allowed per day 
	#'   in the population, used to scale behavioral adjustments under predation risk.
	#'
	#' @return data.frame. A data frame containing the full time-series of state variables for the 
	#'   individual, including:
	#'   \itemize{
	#'     \item currentAge: Age of the individual at each time step.
	#'     \item mature: Logical, whether the individual is mature.
	#'     \item currentDryMass, currentWetMass: Mass components.
	#'     \item nextMassPredicted: Predicted mass at next time step.
	#'     \item massForNextReproduction, ageForNextReproduction: Reproduction targets.
	#'     \item netGrowth, netGrowthEnergyTank: Mass growth accounting for energy and metabolism.
	#'     \item voracity, preFinalVoracity, vorAfterEncounters: Feeding rates adjusted for behavior.
	#'     \item searchAreaRadius, speed, postTspeed: Movement and foraging traits after allometric and plasticity adjustments.
	#'     \item h: Plasticity factor based on condition.
	#'     \item Other auxiliary state variables needed for reproduction, instar tracking, and metabolic losses.
	#'   }
	#'
	#' @details
	#' The simulation proceeds iteratively over each time step in the individual's age vector. The function:
	#' \enumerate{
	#'   \item Initializes state variables for growth, reproduction, and metabolism.
	#'   \item Updates life stage (instar), maturation status, and capital breeding status.
	#'   \item Computes dry mass and energy tank dynamics, considering molting and instar transitions.
	#'   \item Calculates reproduction targets for mature individuals and updates reproduction counters.
	#'   \item Computes next predicted mass using the growth model.
	#'   \item Calculates voracity, metabolic losses, and net growth, considering environmental effects 
	#'         such as predator encounters.
	#'   \item Applies allometric scaling and plasticity to movement and foraging traits.
	#'   \item Updates behavioral and physiological variables at each step, including scope area, 
	#'         interaction radius, and movement speed.
	#' }
	#'
	#' This function is highly modular and can accommodate different species, growth models, and 
	#' simulation types (e.g., Dinosaurs, Arthropods, Aquatic) by adjusting the parameters in the 
	#' `individual` list.
	#'
	#' @examples
	#' \dontrun{
	#' # Simulate a single individual with pre-final voracity limited by target mass
	#' result <- simulateIndividual(
	#'   individual = myIndividual,
	#'   preFinalVoracityFunction = calculatePreFinalVoracityLimited,
	#'   todayEncountersWithPredators = 2,
	#'   maxEncountersPerDayInPop = 10
	#' )
	#' head(result)
	#' }
	#'
	#' @export
	simulateIndividual<-function(individual, preFinalVoracityFunction, todayEncountersWithPredators, maxEncountersPerDayInPop)
	{
		cols <- c("currentAge",
			"mature",
			"nextMassPredicted",
			"massForNextReproduction",
			"ageForNextReproduction",
			"currentLength",
			"currentDryMass",
			"currentEnergyTank",
			"currentBodySize",
			"currentWetMass",
			"mr",
			"targetMasses",
			"voracityAfterApplyProportion",
			"searchAfterAllometric",
			"searchAfterPlasticity",
			"scopeAreaRadius",
			"interactionAreaRadius",
			"speedAfterAllometric",
			"postTspeed",
			"speedAfterPlasticity",
			"preFinalVoracity",
			"voracity",
			"vorAfterEncounters",
			"searchAfterEncounters",
			"searchAreaRadius",
			"speed",
			"vorAfterGarland",
			"vorAfterYodzis",
			"maxMetabolicDryMassLoss","h", "targetEggs","numEggs","reproCounter","netGrowth", "netGrowthEnergyTank",
			"beyondMax","deficit","clutchMass","capitalBreeding","beyondCurve","predVor",
			"instar", "massAtPreviousInstar", "actualMassAtTheBeginningOfReproEvent", "massAtMaturation",
			"firstReproTargetCalculated")

		capta_all<-as.data.frame(matrix(nrow=length(individual$currentAge),ncol=length(cols)))

		names(capta_all)<-cols
		
		capta_all$currentAge <- individual$currentAge

		for(i in 1:length(capta_all$currentAge)){	
			if(all.equal(capta_all$currentAge[i], individual$ageOfFirstMaturation) == TRUE | capta_all$currentAge[i] > individual$ageOfFirstMaturation){  ##round because it fails sometimes
				capta_all$mature[i]<-TRUE
			}else{
				capta_all$mature[i]<-FALSE
			}

			if(i == 1){
				capta_all$instar[i] = 1
			}
			else{
				if(capta_all$instar[i-1] <= length(individual$finalAgeVector)){
					targetTime<-individual$finalAgeVector[capta_all$instar[i-1]]

					if(all.equal(targetTime, capta_all$currentAge[i]) == TRUE | targetTime < capta_all$currentAge[i]){
						capta_all$instar[i] = capta_all$instar[i-1] + 1
					}else{
						capta_all$instar[i] = capta_all$instar[i-1]
					}
				}else{
					capta_all$instar[i] = capta_all$instar[i-1]
				}
			}
		}

		capta_all$capitalBreeding = individual$capitalBreeding 

		capta_all$reproCounter = 0

		capta_all$targetEggs = 0
		capta_all$numEggs = 0

		capta_all$massForNextReproduction = 0.0
		capta_all$ageForNextReproduction = 0

		capta_all$actualMassAtTheBeginningOfReproEvent<-0.0
		capta_all$massAtMaturation<-0.0
		capta_all$firstReproTargetCalculated<-FALSE

		i=1
		while(i <= length(capta_all$currentAge)){	

			if(i>1){ 
				capta_all$reproCounter[i]=capta_all$reproCounter[i-1]
				capta_all$capitalBreeding[i]=capta_all$capitalBreeding[i-1]
				capta_all$currentDryMass[i]=capta_all$netGrowth[i-1]
				capta_all$currentEnergyTank[i]=capta_all$netGrowthEnergyTank[i-1]
				capta_all$currentBodySize[i]=capta_all$currentBodySize[i-1]
				capta_all$massAtPreviousInstar[i]=capta_all$massAtPreviousInstar[i-1]
				capta_all$actualMassAtTheBeginningOfReproEvent[i]=capta_all$actualMassAtTheBeginningOfReproEvent[i-1]
				capta_all$massAtMaturation[i]=capta_all$massAtMaturation[i-1]
				capta_all$firstReproTargetCalculated[i]=capta_all$firstReproTargetCalculated[i-1]
				capta_all$massForNextReproduction[i]=capta_all$massForNextReproduction[i-1]
				capta_all$ageForNextReproduction[i]=capta_all$ageForNextReproduction[i-1]
				capta_all$clutchMass[i]=capta_all$clutchMass[i-1]
				capta_all$targetEggs[i]=capta_all$targetEggs[i-1]
			}else{
				eggDryMassAtBirth = individual$eggDryMass + individual$eggDryMass*individual$traitsTemperature[["base.factorEggMass"]]

				result = setDryMass(
					newDryMass=eggDryMassAtBirth, investment = eggDryMassAtBirth, energyTankTraitValue=individual$traitsTemperature[["base.energy_tank"]], 
					mature = capta_all$mature[i], hasCapitalBreeding = individual$capitalBreeding, numberOfCapitalBreeds = individual$numberOfCapitalBreeds,
					eggsPerBatch = individual$eggsPerBatch, eggDryMassAtBirth = eggDryMassAtBirth, betaScaleTank=individual$betaScaleTank,
					assignedForMolt = individual$assignedForMolt, excessInvestInSize=individual$excessInvestInSize,
					isMoulting = FALSE, checkPreviousValues=FALSE
				)
				
				capta_all$currentEnergyTank[i] = result$energyTank
				capta_all$currentBodySize[i] = result$bodySize

				capta_all$currentDryMass[i] = capta_all$currentBodySize[i] + capta_all$currentEnergyTank[i]

				capta_all$massAtPreviousInstar[i]<-capta_all$currentDryMass[i]
			}

			if(capta_all$currentEnergyTank[i] > 0.0)
			{
				if(i > 1){
					if(capta_all$instar[i] != capta_all$instar[i-1]){

						eggDryMassAtBirth = individual$eggDryMass + individual$eggDryMass*individual$traitsTemperature[["base.factorEggMass"]]

						if(capta_all$currentDryMass[i] <= individual$finalMassesVector[capta_all$instar[i-1]]){
							result = setDryMass(
								newDryMass=capta_all$currentDryMass[i], investment = capta_all$currentDryMass[i], energyTankTraitValue=individual$traitsTemperature[["base.energy_tank"]], 
								mature = capta_all$mature[i], hasCapitalBreeding = individual$capitalBreeding, numberOfCapitalBreeds = individual$numberOfCapitalBreeds,
								eggsPerBatch = individual$eggsPerBatch, eggDryMassAtBirth = eggDryMassAtBirth, betaScaleTank=individual$betaScaleTank,
								assignedForMolt = individual$assignedForMolt, excessInvestInSize=individual$excessInvestInSize,
								isMoulting = TRUE, checkPreviousValues=TRUE, currentBodySize=capta_all$currentBodySize[i],
								currentEnergyTank=capta_all$currentEnergyTank[i]
							)
						}
						else{
							result = setDryMass(
								newDryMass=individual$finalMassesVector[capta_all$instar[i-1]], investment = capta_all$currentDryMass[i], energyTankTraitValue=individual$traitsTemperature[["base.energy_tank"]], 
								mature = capta_all$mature[i], hasCapitalBreeding = individual$capitalBreeding, numberOfCapitalBreeds = individual$numberOfCapitalBreeds,
								eggsPerBatch = individual$eggsPerBatch, eggDryMassAtBirth = eggDryMassAtBirth, betaScaleTank=individual$betaScaleTank,
								assignedForMolt = individual$assignedForMolt, excessInvestInSize=individual$excessInvestInSize,
								isMoulting = TRUE, checkPreviousValues=TRUE, currentBodySize=capta_all$currentBodySize[i],
								currentEnergyTank=capta_all$currentEnergyTank[i]
							)
						}

						capta_all$currentEnergyTank[i] = result$energyTank
						capta_all$currentBodySize[i] = result$bodySize

						capta_all$currentDryMass[i] = capta_all$currentBodySize[i] + capta_all$currentEnergyTank[i]

						capta_all$massAtPreviousInstar[i]<-capta_all$currentDryMass[i]
					}
				}
				
				if(capta_all$massAtMaturation[i] == 0.0){
					if(capta_all$instar[i] == max(capta_all$instar)){

						if(!capta_all$capitalBreeding[i]){
							capta_all$massAtMaturation[i] = calculateDryMass(individual$finalLengthsVector[length(individual$finalLengthsVector)], individual$coefficientForMassAforMature, individual$scaleForMassBforMature)
						}
					}
				}

				if(capta_all$mature[i] & !capta_all$firstReproTargetCalculated[i]){

					reproTarget <- calculateReproTarget(capitalBreeding=capta_all$capitalBreeding[i], indeterminateGrowth=individual$indeterminateGrowth, 
						currentDryMass=capta_all$currentDryMass[i], currentAge=capta_all$currentAge[i], eggsPerBatchFromEquation=individual$eggsPerBatchFromEquation, 
						eggsPerBatch=individual$eggsPerBatch, eggDryMass=individual$eggDryMass, factorEggMassFromMom=individual$traitsTemperature[["base.factorEggMass"]], 
						interceptForEggBatchFromEquation=individual$interceptForEggBatchFromEquation, slopeForEggBatchFromEquation=individual$slopeForEggBatchFromEquation, 
						femaleMaxReproductionEvents=individual$femaleMaxReproductionEvents, timeOfReproEvent=individual$timeOfReproEvent,
						massesVector=individual$finalMassesVector, massAtMaturation=capta_all$massAtMaturation[i], reproCounter=capta_all$reproCounter[i], 
						timeOfReproEventDuringCapitalBreeding=individual$timeOfReproEventDuringCapitalBreeding, tmax=individual$finalAgeVector[length(individual$finalAgeVector)], 
						Lmax=individual$finalLengthsVector[length(individual$finalLengthsVector)], type=individual$growthModel$model, 
						A=individual$growthModel$A, coefficientForMassA=individual$coefficientForMassA, scaleForMassB=individual$scaleForMassB, 
						coefficientForMassAforMature=individual$coefficientForMassAforMature, scaleForMassBforMature=individual$scaleForMassBforMature, 
						growth=individual$traitsTemperature[["base.growth"]], mature=capta_all$mature[i], instar=capta_all$instar[i], maxInstar=max(capta_all$instar), 
						conversionToWetMass=individual$conversionToWetMass[[capta_all$instar[i]]])

					capta_all$massForNextReproduction[i] = reproTarget$massForNextReproduction
					capta_all$ageForNextReproduction[i] = reproTarget$ageForNextReproduction
					capta_all$clutchMass[i] = reproTarget$clutchMass
					capta_all$targetEggs[i] = reproTarget$targetEggs

					capta_all$firstReproTargetCalculated[i] = TRUE
				}

				if(capta_all$mature[i] & capta_all$reproCounter[i] < individual$femaleMaxReproductionEvents){

					result <- checkReproTarget(reproCounter=capta_all$reproCounter[i], numberOfCapitalBreeds=individual$numberOfCapitalBreeds, 
						femaleMaxReproductionEvents=individual$femaleMaxReproductionEvents, currentDryMass=capta_all$currentDryMass[i], 
						currentEnergyTank=capta_all$currentEnergyTank[i], currentAge=capta_all$currentAge[i], capitalBreeding=capta_all$capitalBreeding[i], 
						massAtMaturation=capta_all$massAtMaturation[i], instar=capta_all$instar[i], maxInstar=max(capta_all$instar), 
						massForNextReproduction=capta_all$massForNextReproduction[i], ageForNextReproduction=capta_all$ageForNextReproduction[i], 
						targetEggs=capta_all$targetEggs[i], indeterminateGrowth=individual$indeterminateGrowth, eggsPerBatchFromEquation=individual$eggsPerBatchFromEquation, 
						eggsPerBatch=individual$eggsPerBatch, eggDryMass=individual$eggDryMass, factorEggMassFromMom=individual$traitsTemperature[["base.factorEggMass"]], 
						interceptForEggBatchFromEquation=individual$interceptForEggBatchFromEquation, slopeForEggBatchFromEquation=individual$slopeForEggBatchFromEquation, 
						timeOfReproEvent=individual$timeOfReproEvent, massesVector=individual$finalMassesVector, timeOfReproEventDuringCapitalBreeding=individual$timeOfReproEventDuringCapitalBreeding, 
						tmax=individual$finalAgeVector[length(individual$finalAgeVector)], Lmax=individual$finalLengthsVector[length(individual$finalLengthsVector)], 
						type=individual$growthModel$model, A=individual$growthModel$A, coefficientForMassA=individual$coefficientForMassA, 
						scaleForMassB=individual$scaleForMassB, coefficientForMassAforMature=individual$coefficientForMassAforMature, 
						scaleForMassBforMature=individual$scaleForMassBforMature, growth=individual$traitsTemperature[["base.growth"]], mature=capta_all$mature[i], 
						conversionToWetMass=individual$conversionToWetMass[[capta_all$instar[i]]])

					capta_all$massForNextReproduction[i] = result$massForNextReproduction
					capta_all$ageForNextReproduction[i] = result$ageForNextReproduction
					capta_all$clutchMass[i] = result$clutchMass

					if(!is.na(result$targetEggs)){
						capta_all$targetEggs[i] = result$targetEggs
					}

					if(!is.na(result$numEggs)){
						capta_all$numEggs[i] = result$numEggs
					}
					
					capta_all$reproCounter[i] = result$reproCounter
					capta_all$currentDryMass[i] = result$currentDryMass
					capta_all$currentEnergyTank[i] = result$currentEnergyTank
					capta_all$capitalBreeding[i] = result$capitalBreeding
					capta_all$massAtMaturation[i] = result$massAtMaturation
				}

				if(i == length(capta_all$currentAge)){ 
					capta_all$nextMassPredicted[i] <- capta_all$currentDryMass[i]
				}
				else{
					capta_all$nextMassPredicted[i] <- calculateNextMassPredicted(capta_all$mature[i], capta_all$currentDryMass[i], 
						individual$ageOfFirstMaturation, individual$traitsTemperature[["base.pupaPeriodTime"]], capta_all$currentAge[i], capta_all$currentAge[i+1], 
						Lmax = individual$finalLengthsVector[length(individual$finalLengthsVector)], eggDryMass = individual$eggDryMass, type = individual$growthModel$model, individual$growthModel$A, individual$finalAgeVector[length(individual$finalAgeVector)], individual$traitsTemperature[["base.growth"]], 
						individual$coefficientForMassA, individual$scaleForMassB, capta_all$capitalBreeding[i], capta_all$reproCounter[i], individual$femaleMaxReproductionEvents,
						capta_all$massForNextReproduction[i], capta_all$ageForNextReproduction[i])
				}

				if(capta_all$mature[i]){
					capta_all$currentLength[i]<-calculateDryLength(capta_all$currentDryMass[i], individual$coefficientForMassAforMature, individual$scaleForMassBforMature)
				}else{
					capta_all$currentLength[i]<-calculateDryLength(capta_all$currentDryMass[i], individual$coefficientForMassA, individual$scaleForMassB)
				}
				
				capta_all$currentWetMass[i] = calculateWetMass(capta_all$currentDryMass[i], individual$conversionToWetMass[[capta_all$instar[i]]])

				if(includeMetabolicRate){

					capta_all$mr[i]<-getTotalMetabolicDryMassLoss(wetMass=capta_all$currentWetMass[i], individual$traitsTemperature[["base.met_rate"]], individual$traitsTemperature[["base.actE_met"]], temperature, 
						proportionOfTimeTheAnimalWasMoving = propMov, search_area=0, simulationType, individual$tempFromLab, individual$conversionToWetMass[[capta_all$instar[i]]], multiplierForFieldMetabolicRate, timeStep) 
								
					if((all.equal(individual$ageOfFirstMaturation-round(individual$traitsTemperature[["base.pupaPeriodTime"]] / timeStep), capta_all$currentAge[i]) == TRUE | (individual$ageOfFirstMaturation-round(individual$traitsTemperature[["base.pupaPeriodTime"]] / timeStep)) < capta_all$currentAge[i]) & 
						capta_all$currentAge[i] < individual$ageOfFirstMaturation){

						capta_all$mr[i]<-0.0
					}

				}else{
					capta_all$mr[i] = 0.0
				}

				if(!capta_all$mature[i])
				{
					capta_all$minNextDinoMassPredicted[i] = capta_all$nextMassPredicted[i] - capta_all$nextMassPredicted[i] * individual$minPlasticityKVonBertalanffy
					
					if(simulationType %in% c("Dinosaurs")){
						capta_all$targetMasses[i] = (garland(capta_all$currentWetMass[i])/individual$conversionToWetMass[[capta_all$instar[i]]])*timeStep
					}else{
						capta_all$targetMasses[i] = (yodzis(capta_all$currentWetMass[i],YodzisA=individual$YodzisA,YodzisB=individual$YodzisB)/individual$conversionToWetMass[[capta_all$instar[i]]])*timeStep
					}

					if(capta_all$targetMasses[i]<0){
						capta_all$targetMasses[i] = 0		
					}

					capta_all$targetMasses[i] = capta_all$targetMasses[i] 	
				}
				else 
				{
					capta_all$minNextDinoMassPredicted[i] = capta_all$nextMassPredicted[i] - capta_all$nextMassPredicted[i] * individual$minPlasticityKVonBertalanffy
					
					if(simulationType %in% c("Dinosaurs")){
						capta_all$targetMasses[i] = (garland(capta_all$currentWetMass[i])/individual$conversionToWetMass[[capta_all$instar[i]]])*timeStep
					}else{
						capta_all$targetMasses[i] = (yodzis(capta_all$currentWetMass[i],YodzisA=individual$YodzisA,YodzisB=individual$YodzisB)/individual$conversionToWetMass[[capta_all$instar[i]]])*timeStep
					}

					if(capta_all$targetMasses[i]<0){
						capta_all$targetMasses[i] = 0		
					}
					
					capta_all$targetMasses[i] = capta_all$targetMasses[i] 
				}

				if(i>1){
					deficit = capta_all$nextMassPredicted[i-1] - capta_all$netGrowth[i-1]

					if(deficit<0)
					{
						capta_all$deficit[i]<-0.0
					}else{
						capta_all$deficit[i]<-deficit
					}
				}else{
					capta_all$deficit[i]<-0.0
				}

				if(!capta_all$capitalBreeding[i] | !capta_all$mature[i])
				{
					capta_all$predVor[i]=(capta_all$nextMassPredicted[i]-capta_all$currentDryMass[i]+capta_all$mr[i]+capta_all$deficit[i])/individual$traitsTemperature[["base.assim"]] ##where assim must be minimum assim (like feeding on the least profitable prey)	   
				}else{
					capta_all$predVor[i]=0
				}

				capta_all$preFinalVoracity[i]=preFinalVoracityFunction(capta_all$targetMasses[i],capta_all$predVor[i])

				capta_all$beyondCurve[i]<-ifelse(capta_all$preFinalVoracity[i] == capta_all$predVor[i],TRUE,FALSE)

				if((all.equal(individual$ageOfFirstMaturation-round(individual$traitsTemperature[["base.pupaPeriodTime"]] / timeStep), capta_all$currentAge[i]) == TRUE | (individual$ageOfFirstMaturation-round(individual$traitsTemperature[["base.pupaPeriodTime"]] / timeStep)) < capta_all$currentAge[i]) & 
					capta_all$currentAge[i] < individual$ageOfFirstMaturation){

					capta_all$beyondCurve[i]<-TRUE
					capta_all$predVor[i]<-0.0
					capta_all$preFinalVoracity[i]<-0.0
				}

				if(capta_all$preFinalVoracity[i] > 0 && capta_all$nextMassPredicted[i] > 0.00000001) ##when slope and interceptTarget = 0
				{
					capta_all$h[i]<-calculateH(
						actualTimeStep=i, 
						capta_all=capta_all,
						individual=individual
					)

					capta_all$voracityAfterApplyProportion[i] = capta_all$preFinalVoracity[i] * individual$traitsTemperature[["base.voracityProportion"]]
					
					if(capta_all$voracityAfterApplyProportion[i] < 0.0) {
						capta_all$voracityAfterApplyProportion[i] = 0.0
					}


					capta_all$searchAfterAllometric[i] = applyAllometricModel(
						dryMass=capta_all$currentDryMass[i],
						coefficient=individual$traitsTemperature[["base.coeffMassForSearchRadius"]],
						scale=individual$traitsTemperature[["base.scaleMassForSearchRadius"]]
					)

					capta_all$searchAfterPlasticity[i] = applyPlasticityDueToConditionToTrait(
						traitValue=capta_all$searchAfterAllometric[i],
						plasticityDueToCondition=individual$plasticityDueToConditionSearch,
						h=capta_all$h[i]
					)


					capta_all$scopeAreaRadius[i] = applyAllometricModel(
						dryMass=capta_all$currentDryMass[i],
						coefficient=individual$traitsTemperature[["base.coeffMassForScopeRadius"]],
						scale=individual$traitsTemperature[["base.scaleMassForScopeRadius"]]
					)


					capta_all$interactionAreaRadius[i] = applyAllometricModel(
						dryMass=capta_all$currentDryMass[i],
						coefficient=individual$traitsTemperature[["base.coeffMassForInteractionRadius"]],
						scale=individual$traitsTemperature[["base.scaleMassForInteractionRadius"]]
					)


					capta_all$speedAfterAllometric[i] = applyAllometricModel(
						dryMass=capta_all$currentDryMass[i],
						coefficient=individual$traitsTemperature[["base.coeffMassForSpeed"]],
						scale=individual$traitsTemperature[["base.scaleMassForSpeed"]]
					)

					capta_all$postTspeed[i] = calculatePostTSpeed(
						simulationType=simulationType,
						speedAfterAllometric=capta_all$speedAfterAllometric[i],
						wetMass=capta_all$currentWetMass[i]
					)

					capta_all$speedAfterPlasticity[i] = applyPlasticityDueToConditionToTrait(
						traitValue=capta_all$postTspeed[i],
						plasticityDueToCondition=individual$plasticityDueToConditionSpeed,
						h=capta_all$h[i]
					)



					if(todayEncountersWithPredators>0){
						hEnc = (1-(todayEncountersWithPredators/maxEncountersPerDayInPop)) 
						
						if(hEnc<0) hEnc = 0
						
						capta_all$vorAfterEncounters[i] = capta_all$voracityAfterApplyProportion[i]*(1-exp(-individual$activityUnderPredationRisk*hEnc))
						capta_all$searchAfterEncounters[i] = capta_all$searchAfterPlasticity[i]*(1-exp(-individual$activityUnderPredationRisk*hEnc))
					}
					else{
						capta_all$vorAfterEncounters[i] = capta_all$voracityAfterApplyProportion[i]
						capta_all$searchAfterEncounters[i] = capta_all$searchAfterPlasticity[i]
					}


					capta_all$searchAreaRadius[i] = capta_all$searchAfterEncounters[i]

					capta_all$speed[i] = capta_all$speedAfterPlasticity[i]

					capta_all$voracity[i] = capta_all$vorAfterEncounters[i]



					capta_all$searchAreaRadius[i] = capta_all$searchAreaRadius[i] * timeStep
				}
				else
				{
					capta_all$searchAfterAllometric[i] = 0.0
					capta_all$searchAfterPlasticity[i] = capta_all$searchAfterAllometric[i]
					capta_all$searchAfterEncounters[i] = capta_all$searchAfterPlasticity[i]
					capta_all$searchAreaRadius[i] = capta_all$searchAfterEncounters[i]

					capta_all$scopeAreaRadius[i] = 0.0

					capta_all$interactionAreaRadius[i] = 0.0

					capta_all$speedAfterAllometric[i] = 0.0
					capta_all$postTspeed[i] = capta_all$speedAfterAllometric[i]
					capta_all$speedAfterPlasticity[i] = capta_all$postTspeed[i]
					capta_all$speed[i] = capta_all$speedAfterPlasticity[i]

					capta_all$voracityAfterApplyProportion[i] = 0.0
					capta_all$vorAfterEncounters[i] = capta_all$voracityAfterApplyProportion[i]
					capta_all$voracity[i] = capta_all$vorAfterEncounters[i]
				}


				if(includeMetabolicRate){

					capta_all$maxMetabolicDryMassLoss[i] = getTotalMetabolicDryMassLoss(wetMass=capta_all$currentWetMass[i], 
						individual$traitsTemperature[["base.met_rate"]], individual$traitsTemperature[["base.actE_met"]], temperature, 
						proportionOfTimeTheAnimalWasMoving = 1, search_area=capta_all$searchAfterEncounters[i], 
						simulationType, individual$tempFromLab, individual$conversionToWetMass[[capta_all$instar[i]]], multiplierForFieldMetabolicRate, timeStep) 

				}else{

					capta_all$maxMetabolicDryMassLoss[i] = 0.0

				}

				
				capta_all$netGrowthEnergyTank[i] <- capta_all$currentEnergyTank[i] + capta_all$vorAfterEncounters[i]*(profitability + individual$traitsTemperature[["base.assim"]]) - capta_all$mr[i]

				capta_all$netGrowth[i] <- capta_all$currentBodySize[i] + capta_all$netGrowthEnergyTank[i]


				if(capta_all$netGrowthEnergyTank[i] < 0.0){
					capta_all$netGrowthEnergyTank[i] = 0.0
				}
			}
			else
			{
				capta_all$netGrowth[i] = capta_all$currentDryMass[i]

				capta_all$netGrowthEnergyTank[i] = capta_all$currentEnergyTank[i]
			}



			i=i+1

		}


		return(capta_all)
	}



    set.seed(123)



	if(temperature == "useTempFromLab"){
		temperature = data_species$tempFromLab
	}


	individual <- generateIndividual(data_species, temperature, timeStep, timeAddedToMeetLastRepro, N, corrLk, corrLdevT, corrkdevT, silent)


	simulations <- list()

	simulations[["Limited"]] <- simulateIndividual(individual, calculatePreFinalVoracityLimited, todayEncountersWithPredators, maxEncountersPerDayInPop)

	simulations[["Unlimited"]] <- simulateIndividual(individual, calculatePreFinalVoracityUnlimited, todayEncountersWithPredators, maxEncountersPerDayInPop)



	return(list(
		simulations=simulations,
		individual=individual
	))

}
